## **1.需求与用例**

参与者（actor）：发生了动作的人
场景（scenario）：是参与者与系统之间一系列特定的动作和交互，也被称为用例实例。
用例（use case）：描述使用系统去完成一个目标的成功和失败场景的集合

主要参与者（Primary actor）：有使用目标完成需求
协助参与者（Supporting actor）：提供服务，使接口和协议清晰化
幕后参与者（Offstage actor）：对用例的行为感兴趣，比如政府税务机关

多个用例实例（场景）抽象出用例，场景是其中一条执行路径
用例捕获现实世界的需求，表示为系统所提供的服务

用例（use case）特征：
​	1.一组用例实例              2.可观测到的、有价值的结果
​	3.系统执行                     4.特定的参与者

用例和功能的区别：
​	1.功能是脱离使用者愿望存在的
​	2.功能是孤立的

问题域 => 需求规格 => 用例图、用例描述（重要）
用例图：
​	1.用例 	2.参与者    3.关系

**分析师必学元素**：1.识别参与者	2.识别用例
​	   		     3.绘制用例图	4.编写用例描述

参与者：在**系统之外**（责任边界），通过系统边界与系统进行**直接**有意义交互的**任何事物**
​	      **直接并主动**向系统发出动作，能从系统获得反馈，有完整的业务目标，系统为他服务

识别用例：1.选择系统边界	2.确定主要参与者
​		  3.确定每个主要参与者的目标	4.定义满足用户目标的用例，根据其目标对用例命名

通过确定**外部事件**，可以有助于寻找参与者和目标
为每个用户目标分别定义一个用例，以“**动词+名词**”的形式命名
写出“**参与者-目标**”列表，复审并精化，绘制用例图

注意事项：
​	1.可观测  =>  用例止于系统边界
​	2.结果值  => 用例是目标导向的
​	3.系统执行  => 结果值由系统生成
​	4.由参与者观测  => 业务语言、用户观点
​	5.执行者角度  => 动词+名词

| 阶段                        | 粒度                                         | 例子                               |
| --------------------------- | -------------------------------------------- | ---------------------------------- |
| 业务建模 （描述功能性需求） | 用例名称能够说明一个完整业务流程             | 取钱、报装电话、借书等             |
| 概念建模                    | 用例描述一项完整业务的一个步骤               | 提供申请资料、受理业务等           |
| 系统建模                    | 用例能够描述操作者与计算机的一次完整交互为宜 | 填写申请单、审核任务单、验证密码等 |

**用例描述组成：**

| 用例的不同部分                                       | 注解                                 |
| ---------------------------------------------------- | ------------------------------------ |
| 用例名称 Use Case Name                               | 动词+名词                            |
| 范围 Scope                                           | 要设计的系统                         |
| 级别 Level                                           | “用户目标”或者是“子功能”             |
| 主要参与者 Primary Actor                             | 与系统交互完成服务                   |
| 涉众及观众点 Stakeholders and Interests              | 关注该用例的人及其需求               |
| 前置条件  Preconditions                              | 值得告诉读者，开始前必须为真的条件   |
| 成功保证 Success Guarantee                           | 值得告诉读者，成功完成必须满足的条件 |
| 主成功场景 Main Success Scenario                     | 典型的、无条件的、理想方式的成果场景 |
| 扩展 Extensions                                      | 成功或失败的替代场景                 |
| 特殊需求 Special Requirements                        | 相关的非功能需求                     |
| 技术和数据变元表 Technology and Data Variations List | 不同的I/O方法和数据格式              |
| 发生频率 Frequency of Occurrence                     | 影响对实现的调查、测试和时间安排     |
| 杂项 Miscellaneous                                   | 例如未决问题                         |

涉众：是与要建设的业务系统相关的一切人和事
**书写用例描述总原则**：如果涉众不能理解和验证，它就不是需求
主成功场景（基本事件流）：客户最想看到、最关心的路径
用例事件流四部曲：请求、验证、改变、回应

---

## **2.类图（域模型）**

概念类：1.符号：表示概念类的词语或图形
​	      2.内涵：概念类的定义
​	      3.外延：概念类所适用的一组示例

领域模型：对领域内的概念类或现实中的可视化表示，**只有属性没有定义操作**的类图
​		  **领域对象：**类	**关联：**：联系		**属性**

**分析师必学元素**：1.识别概念类	2.UML类图
​			     3.类及类的关联关系      4.建立领域模型

找概念类方法：1.重用和修改现有模型
​			  2.使用分类列表
​			  3.确定名词短语：将对领域的文本描述中的名词和名词短语作为候选的概念类或属性

**CRC分析法**（Class-Responsibility-Collaborator）：
​	1.类：代表了一组“候选关键抽象”
​	2.职责：类知道或者做的任何事情
​	3.协作者：包含需要的信息或者需要的事务。

用CRC分析法识别关键抽象
​	1.选择一个**候选的关键抽象**
​	2.确定一个与该候选关键抽象显著相关的用例.
​	3.查看用例描述（场景）和系统的功能需求来确定**职责和协作**关系.
​	4.用CRC卡记录抽取出来的关键抽象
​	5.基于以上的工作,更新候选关键抽象表格.

候选的关键抽象排除的原因：
​	1.系统之外，无关联	
​	2.冗余类
​	3.（该名词是）是关键抽象的属性（现实世界中的数字或文本）
​	4.仅有一个实例

**类图(class diagram)**：用来表达业务领域或系统内部的静态结构(static structure)。
​	1.分析人员：可通过类图进行业务建模，描述业务领域内概念类及其之间关系的静态结构。
​	2.设计人员可通过类图进行系统设计，将程序代码分门别类，构成了系统内部的静态结构。

类的组成：1.名字	2.属性	3.操作

领域模型中属性的类型更应该是数据类型，通过关联而不是属性来表示概念类之间的关系
​		(对抽象类建立类图，属性是基本数据类型，**任何属性都不表示外键**，而用关联表示)**

**建立领域模型：**
​	1.识别概念类
​		（1）关键抽象、CRC
​		（2）重用或修改现有的模型
​		（3）使用分类表
​	2.UML定义类及属性
​	3.定义关联名和角色名
​	4.定义并记录关联重数
​	5.定义并记录关联方向

用户通过手机登录购票系统，注册会员，票务查询，下单，支付，购票系统订单管理，用户评价，手机验票

| 候选的关键抽象 | 排除的原因   | 选定的名字 |
| -------------- | ------------ | ---------- |
| 手机           |              | 手机       |
| 会员           | 是用户的属性 |            |
| 票务系统       |              | 票务系统   |
| 门票           |              | 门票       |
| 订单           |              | 订单       |
| 评价           | 是用户的属性 |            |
| 用户           |              | 用户       |
| 购票系统       | 仅有一个实例 |            |
| 验票机         | 系统之外     |            |

---

## **3.Interaction Diagram（交互图）**

**UML动态模型：**
​	1.交互图（ Interaction Diagram）
​		1.1.顺序图（ Sequence Diagram）：
​			按照时间顺序来描述对象的交互，强调了消息发生的时间顺序。
​		1.2.通信图（ Communication Diagram）：
​			围绕着对象和对象之间的链接来描述对象的交互，强调对象的组织结构。
​	2.状态图（State Diagram ）
​		对一个类的生命循环建模，对复杂的动态行为有用。
​	3.活动图（ Activity Diagram ）
​		活动到活动之间的控制流，用于对业务过程、工作流建模，也可以对用例实现建模

**用例图－类图－交互图:**

| 用例图                 | 类图                   | 交互图                 |
| ---------------------- | ---------------------- | ---------------------- |
| 动态行为(系统外在行为) | 静态结构(系统内在结构) | 动态行为(系统内在行为) |
| 参与者、用例           | 类                     | 对象(object)           |
| 包含、扩展             | 关联                   | 消息(message)          |
| 用例描述               | 关键抽象、CRC          | BCE模式                |
| 业务流程               | 领域概念               | 概念与流程的关联       |

**顺序图：**  显示**一组对象**为了实现某种**功能**，而彼此**发送和接收**的一串**消息**
​		强调**消息时间顺序**
顺序图建模元素：1.对象（Object）	2.生命线（Lifeline）
​			     3.消息（Message）   4.执行规格条（ExecutionSpecification bar）

异步和同步调用：
​	1.异步消息调用不等待响应，不会阻塞。
​	2.异步消息在多线程环境中使用。
​	3.刺形箭头消息表示异步调用，实心箭头消息表示同步调用。
​	4.在阅读草图时，不要假设箭头的形状是正确的

系统顺序图(SSD)：是阐述与**所讨论系统**相关的**输入和输出事件**而快速、简单创建的**顺序图**。
​	SSD展示了直接与系统交互的**外部参与者**对**系统**（黑盒）发起的**系统事件**以及其顺序。
​	系统被视为**黑盒**，该图强调的是从参与者到系统的**跨越系统边界的事件**。
**准则**：应为每个用例的主成功场景，以及频繁发生或者复杂的替代场景绘制SSD
**从用例模型的系统顺序图扩展为设计模型的顺序图**

**GRASP：General Responsibility Assignment Software Pattern：**

![1542011308747](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1542011308747.png)

**鲁棒性分析：**
​	1.一种方法：通过分析用例规约中的事件流，识别出实现用例规定的功能所需的主要对象及其职责，形成以职责模型为主的初步设计。
​	2.一个过程：它引导我们从用例创建一个支持用例的设计组件模型。它被称为设计模型。
​			     需求模型 => 设计模型

鲁棒图包含三种元素：边界对象、控制对象和实体对象
​	边界对象——用来隔离系统内外，通常负责接收并响应系统内外的信息。
​	控制对象——用来控制用例执行期间的复杂运算或者业务逻辑，通常针对一个用例，就会	对应生成一个控制类。
​	实体对象——保存问题领域中的重要信息，封装数据结构和数据储存有关的变化。

| 鲁棒图的元素 | 职责 | 组成架构的元素 | MVC架构的元素 |
| ------------ | ---- | -------------- | ------------- |
| 边界对象     | 交互 | 连接元素       | 视图          |
| 控制对象     | 控制 | 处理元素       | 控制器        |
| 实体对象     | 信息 | 数据元素       | 模型          |

**鲁棒图建模原则：**
​	(1) 参与者只能与边界对象交谈
​	(2) 边界对象只能与控制体和参与者交流
​	(3) 实体对象也只能与控制体交谈
​	(4) 控制体既能与边界对象交谈，也能与控制体交谈，但不能与参与者交谈

鲁棒性分析的输入：
​	一个用例
​	这个用例的用例场景
​	这个用例的活动图（如果可以用到）
​	域模型（domain model）
鲁棒性分析的输出：
​	UML交互图
​	一些设计组件：边界、服务、实体组件，
​	得出设计模型。

过程描述：
​	1.选择一个用例。
​	2.构造一个满足用例活动性的通信图。
​		a.识别支持用例活动的设计组件。
​		b.画出这些组件间的关联
​		c.用信息标记这些关联
​	3.从另一个角度，把通信图转换成顺序图（可选的）。

演示：
​	1.选择一个适当的用例。
​	2.把一个参与者放到通信图里面。
​	3.分析这个用例（活动图）。
​		对于用例的每一个动作：
​		a.确定并增加边界组件
​		b.确定并增加服务组件
​		c.确定并增加实体组件
​		d.画出这些组件间的关联
​		e.把每个组件都贴上用来满足用例交互的动作标签

---

## **4.用例图（设计）**

**从分析到设计：**
​	用例图—放进开发人员的观点，使用包含关系和扩展关系，罗列出可以共享的部分，并且让用例图更为细致化。
​	类图—分析师所生成的类图（域模型）通常跟实际工作平台有些差别，所以设计师要补上一些实际工作平台的概念。
​	交互图（序列图）—在分析阶段的交互图并没有太重视消息上的参数，在设计阶段，每张交互图都要拿出来再检查一次，加上所需的参数。

**设计师必学元素：**
​	识别用例关系
​	对用例进行优先级排序

用例关系：
​	1.包含关系（has）               ![1542029907858](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1542029907858.png)     提取公共交互，提高复用
​	2.扩展关系 （增值业务）     ![1542029877895](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1542029877895.png)    “冻结”基础用例以保持稳定
​	3.泛化关系  （is a ）            ![1542029958977](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1542029958977.png)          同一业务目的的不同技术实现
需求分析的主要工作是**写文本**

具体用例（Concrete Use Case）
​	由参与者发起，完成了参与者所期望的完整行为.如”处理销售“.
抽象用例（Abstract Use Case）
​	永远不能被自己实例化.如”信用卡支付“，不能独立存在.
基础用例（Base Use Case）
​	包含其他用例的用例，或者是被其它用例扩展或者泛化的用例，如”处理销售“.
附加用例（Additional Use Case）
​	被其他用例包含的用例，或者扩展、泛化其它用例的用例，如”信用卡支付“.
附加用例通常是抽象用例，基础用例通常是具体用例

| 包含关系                    | 扩展关系                       |
| --------------------------- | ------------------------------ |
| 标示<<include>>的带箭头虚线 | 标示<<extend>>的带箭头虚线     |
| 基础用例指向被包含的小用例  | 小用例指向被扩充的基础用例     |
| 一定要执行小用例            | 条件成立（扩展点）才执行小用例 |

泛化关系：执行子用例的用例实例将遵循父用例的事件流，同时插入附加行为或修改在子用例事件流中定义的行为。

**用例描述重点加工：**
​	1.用例之间的关系—如果有使用包含关系和扩展关系的话，在用例描述处，就要记得说明。
​	2.边界对象的沟通接口—参与者对象与边界对象之间的沟通接口，必须描述的更明确些。
​	3.加入伪界面—如果分析师在项目一开始未绘制出伪界面的话，在设计师开始为分析文件细部加工的时候，最好已经绘制出伪界面了，这样就可以搭配用例描述把边界对象说得更详细些。
​	4.更新BCE类—前面我们已经更新过实体类了，所以此时更新的重点会摆在边界类与控制类。

**工时估算：**Gustav karner 先生所提出的用例点公式
​	1.未经调整的用例点=参与者总权重+用例总权重
​	2.技术复杂系数=0.6+(0.01*技术总权重)
​	3.环境系数=1.4+(-0.03*环境总权重)
​	4.用例点=未经调整的用例点*技术复杂系统*环境系数
​	5.工时=用例点*20人时(或28人时)

---

## **5.类图（设计）**

分析类三高
​	**高于设计实现**，不必应用采用的设计模式，系统框架等。
​	**高于语言实现**，不必理会采用哪一种特性的语言来编码。
​	**高于实现方式**，可以不考虑采用哪一种具体的实现方式。
设计类 
​	设计类是系统实施中一个或多个对象的抽象；设计类所对应的对象取决于实施语言。 

**设计师必学元素**
​	创建设计类
​	识别类、方法、依赖关系、泛化关系，并在设计类图中表示。
​	理解接口与实现、抽象类、保护等级、类层级、公有类、枚举类型

| 结构 | 说明                                                         | 语法                                                         |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 依存 | 如果一个类依靠另一个类的服务来完成其职责（角色），则它们之间的关系称为依赖关系 | ![1542075102699](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1542075102699.png) |

**依赖关系：**表示的是类之间的调用关系，即用一个类去调用另外一个类，被调用的类表现为调用类的局部变量、方法的参数，调用类调用被调用类的静态方法。

依赖关系与关联关系的区别：
​	从类之间关系的时间角度来分，关联表示类之间的“**持久、静态**”关系，一般需要“**持久化**”的，或者说需要**保存到数据库中**的，是一种重要的业务之间的关系。依赖表示类之间的是一种“**短暂、动态**”关系，这种关系是**不需要保存**的。
​	从类之间关系的强弱程度来分，关联表示类之间的很强的关系；依赖表示类之间的较弱的关系。
​	设计类之间的关系遵循的原则：首先判断是否是一种“关联”关系，若不是再判断是否是“依赖关系”，一般情况下若不是关联，就是依赖关系
​	依赖关系（Dependency relationship ）：是类与类之间的连接，**依赖总是单向的**。
​	关联关系（Association relationship）：是一种**结构关系**，是指一个类的对象与另一个类的对象之间的关系（具有多重性）。关联可以有方向，即导航。一般不作说明的时候，导航是双向的，不需要在线上标出箭头。关联在代码中一般表示为**属性（成员变量）**

**泛化**：标识各个类之间的共同性。 
​	指明特化类（子类）的对象可取代泛化类（父类）的对象。
​	是“is-a”关系。

**接口与抽象类的区别：**
​	1.类是对对象的抽象，可以把抽象类理解为把类当作对象，抽象成的类叫做抽象类.而接口只是一个行为的规范或规定，证明其是表述一类“我能做…”，抽象类更多的是定义在一系列紧密相关的类间，而接口大多数是关系疏松但都实现某一功能的类中. 
​	2.接口基本上不具备继承的任何具体特点,它仅仅承诺了能够调用的方法;
​	3.一个类一次可以实现若干个接口,但是只能扩展一个父类
​	4.抽象类和接口就是定义为**不可变的**，而把可变的放到子类去实现，实现了oop中的一个原则，把**可变的与不可变的分离**。

**类设计－重点加工的部分:**
​	1.把中文的类名称、属性名称、操作名称都变成**英文**。
​	2.针对每一个用例，建立BCE类图，并且加上BCE类之间的依赖关系。
​	3.针对前述提到的依赖关系、泛化关系、保护等级可见性、抽象类、类层级属性与操作、公有类和枚举类型，都要找一找修正一下实体类图。
​	4.针对更新后的实体类图，加上适当的**主键和外键**。

---

## **6.面向对象设计原则**

**设计目标**
​	可扩展性 （Extensibility）
​	灵活性 （Flexibility）
​	健壮性（ Robustness ）
​	可插入性 （Pluggability）
​	。。。。。。

**什么是好的设计？**
​	容易理解
​	容易修改和扩展
​	容易复用
​	容易实现与应用
​	简单、紧凑、经济适用
让人工作起来**心情愉快**的设计

### **面向对象的基本设计原则：**

LSP：Liskov替换原则
​	The Liskov Substitution Principle
OCP：开放-封闭原则
​	The Open-Close Principle
SRP：单一职责原则
​	The Single Responsibility Principle
ISP：接口隔离原则
​	The Interface Segregation Principle 
DIP：依赖倒置原则
​	The Dependency Inversion Principle
。。。。。。

**LSP（The Liskov Substitution Principle, Liskov替换原则）：**

- “若对于类型S的任一对象o1，均有类型T的对象o2存在，使得在T定义的所有程序P中，用o1替换o2之后，程序的行为不变，则S是T的子类型”
- 如果在任何情况下，子类（或子类型）或实现类与基类都是可以互换的，那么继承的使用就是合适的。为了达到这一目标，**子类不能添加任何父类没有的附加约束**
- “子类对象必须可以替换基类对象”

里氏替换原则通俗的来讲就是：**子类可以扩展父类的功能，但不能改变父类原有的功能**
1.子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。
2.子类中可以增加自己特有的方法
3.当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。
4.当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。

**OCP（The Open-Close Principle, 开放-封闭原则）：**
​	软件实体（类、模块、函数等）应该是可扩展的，但是不可修改的
​	**对于扩展是开放的（Open for extension）**
​		模块的行为可以扩展，当应用的需求改变时，可以对模块进行扩展，以满足新的需求
​	**对于更改是封闭的（Closed for modification）**
​		对模块行为扩展时，不必改动模块的源代码或二进制代码
​	**OCP的关键在于抽象**
​		抽象技术：abstract class, Interface
​		抽象预见了可能的所有扩展（闭）
​		由抽象可以随时导出新的类（开）

**SRP（The Single Responsibility Principle, 单一职责原则）：**
​	就一个类而言，应该**仅有一个**引起它变化的原因（**通过增加新的类分离职责来实现**）
​	SRP体现了**内聚性（Cohesion）**：一个模块的组成元素之间的功能相关性
​	**类的SRP原则实现起来较为困难，但是接口设计必须满足SRP原则**

**ISP（ The Interface Segregation Principle，接口隔离原则）：**
​	客户不应该依赖他们用不到的方法，只给每个客户它所需要的接口
​	为了避免“肥接口(fat interface)”，以一个类实现多个接口，而各客户仅仅获知必须的接口
解决方案：**分离接口**
​	1.使用委托分离接口（Adapter模式）
​	2.使用多重继承分离接口
**ISP本质：**
​	使用多个专门的接口比使用单一的接口好
​	一个类对另一个类的依赖性应当是建立在最小的接口上的
​	避免接口污染（Interface Pollution）

**“依赖于抽象”**：程序中所有依赖关系都应该终止于抽象类或者接口

**DIP（依赖倒置原则，The Dependency Inversion Principle）：**
​	高层模块不应该依赖于低层模块。二者都应该依赖于抽象
​	抽象不应该依赖于细节。细节应该依赖于抽象
​	针对接口编程，不要针对实现编程

**Booch（人名）**：所有结构良好的面向对象架构都具有清晰的层次定义，每个层次通过一个定义良好的、受控的接口向外提供了一组内聚的服务

**启发式原则：**
​	任何变量都不应该拥有指向具体类的指针或者引用
​	任何类都不应该从具体类派生
​	任何方法都不应该改写其任何基类中已经实现的方法

**在软件设计中，抽象有两层含义：**
​	提供下层机制的良好抽象，使高层次的操作无需顾及到下层的细节问题。比如JVM、CORBA
​	抓住**客观世界的本质**，把握和描述这个本质，建立抽象的概念，通过对这种概念的描述，**隔离可能发生的变化**

---

## **7. GRASP：基于职责设计对象**

模式的一个**主要目标**：以一种别人容易接受的方式，捕捉那些重复出现的问题的解决方案

**设计模式**是一些针对特定问题的成功的解决方案
例如：  模式名：信息专家（Information Expert）
​		问题：分配职责给对象的基本原则是什么？
​        解决方案：将职责分配给信息专家 -- 含有满足职责所需信息的类。

**设计模式的基本要素：**
​	1.名称：用于助记，形象表示这个模式
​	2.问题：这个模式可以解决什么问题
​	3.解决方案：这个模式怎样解决这个问题的步骤与方法
​	4.效果：使用这个模式与不使用这个模式有什么区别，它有什么优点和缺点 （**灵活**）

**设计模式的基本思想：**
​	1.设计模式是为了让软件更加适应变化，有更多的**可复用性**
​		就应该**封装变化**，让变化的影响最小
​		**封装复杂性**，提供简单的接口 
​	2.1.**松耦合**(用抽象解耦，高内聚，低耦合)
​	2.2.针对**接口编程**，而不是针对实现编程
​	2.3.**继承、组合、委托、多态、参数化**
​	

**职责和方法responsibility-driven design or RDD **
​	UML定义职责(Responsibility)为“类元的契约或义务”。
 	方法(Method)用来实现（履行）职责。

**职责可分成两类：**
​	“认知”职责（knowing）：
​		 “知道”私有的封装数据
 		“知道”相关联的对象
​		 “知道”能够派生或计算出的事物
 	“行为”职责（doing）：
​		“做”自身的一些事情。如创建一个对象或进行一次计算。
 		“做”其它对象的初始化操作。
 		控制和协调其它对象的活动。

在UML制品（artifacts）中，通常是在建立**交互图的语境**来考虑对象的职责分配，通过方法来实现职责。

**GRASP**：通用职责分配软件模式（General Responsibility Assignment Software Pattern）
​	创建者(Creator)
​	信息专家(Information Expert)
​	低耦合(Low Coupling)
​	控制器(Controller)
​	高内聚(High Cohesion)
​	多态（Polymorphism）
​	纯虚构（Pure Fabrication）
​	间接性（Indirection）
​	防止变异（Protected Variations）

**创建者（Creator）：**
​	模式名：创建者
​	问题：谁创建了A？
​	解决方案(可被视作建议)：如果以下条件之一成立，则可以将创建类A实例的职责分配给类B。
​	B包含了A对象； B组成聚集了A；
​	B记录了A；
​	B紧密地使用A；
​	B具有A的初始化数据

**信息专家（Information Expert）：**
​	模式名：信息专家（或专家）
​	问题：给对象分配职责的基本原则是什么？
​	解决方案(建议)：将职责分配给具有完成该职责所需信息的那个类（查找具有完成职责所需信息的类，修改类的职责）

**低耦合（Low Coupling）：**
​	模式名：低耦合
​	问题：怎样降低依赖性，减少变化带来的影响，提高重用性？
​	解决方案(建议)：分配职责，使耦合尽可能低。利用这一原则来评估可选方案。

**控制器（Controller）：**
​	模式名：控制器
​	问题：在UI层之上首先接收和协调(控制)系统操作的对象是什么？
​	解决方案：将接收或处理系统事件消息的**职责分派**给代表下列事务的类：
​		代表全部“系统”或“根对象”，如MonopolyGame对象
​		代表运行软件的设备，如Phone，BankCashMachine
​		代表用例或会话出现。通常命名为<用例名>Handler， <用例名>Session。如，		PlayMonopolyGameHandler。
​	常见缺陷：分配的职责过多，从而违反了高内聚的原则
​	准则：正常情况下，控制器应当把需要完成的工作委派给其它对象。
​	**UI对象和UI层不应具有实现系统事件的职责。系统操作应该在应用逻辑层或领域层完成。**

**高内聚（High Cohesion）：**
​	模式名：高内聚
​	问题：怎样使对象保持有内聚、可理解和可管理，同时具有支持低耦合的附加作用？
​	解决方案：职责分配应保持高内聚，依此来评估备选方案。

高内聚度是对一个类中的各个职责之间相关程度和集中程度的度量。
一个具有高度相关职责的类并且这个类所能完成的工作量不是特别巨大，那么它就具有高内聚度。
包括两个意思：
 	1.**不要给一个类分派太多的职责**，在履行职责时尽量将部分职责分派给有能力完成的其它类去完成。
 	2.不相关的职责不要分派给同一个类。

浮肿的控制器：
​	在系统中只有一个简单的控制器接收所有的系统事件，并且系统事件非常多。
 	控制器本身执行许多实现系统事件必需的任务，而没有把工作委托给别的类。
 	控制器本身具有许多属性，并维护着系统或者领域中本应该分布到其它对象的大量信息，或在别处可以找到的重复信息。
避免方法：
​	1.增加控制器。使用用例控制器，而不是外观控制器
​	2.设计控制器，使它把完成每个系统操作的职责委派给其它对象

---

## **8.GRASP更多具有职责的对象**

**多态（Polymorphism）：**
​	模式名：多态（Polymorphism）
​	问题：如何基于类型选择？如何创建可插拨的软件构件？
​	解决方案：当相关的或行为随类型（类）有所不同时，使用“多态操作”为变化的行为类型分配职责 。
​	推论：不要测试对象的类型，也不要使用条件逻辑来执行基于类型的不同选择